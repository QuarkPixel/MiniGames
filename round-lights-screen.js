function resize(){const{innerWidth:n,innerHeight:t}=window;canvas.width=n*dpr,canvas.height=t*dpr,gl.viewport(0,0,n*dpr,t*dpr)}function compile(n,t){gl.shaderSource(n,t),gl.compileShader(n),gl.getShaderParameter(n,gl.COMPILE_STATUS)||console.error(gl.getShaderInfoLog(n))}function setup(){const n=gl.createShader(gl.VERTEX_SHADER),t=gl.createShader(gl.FRAGMENT_SHADER);program=gl.createProgram(),compile(n,vertexSource),compile(t,fragmentSource),gl.attachShader(program,n),gl.attachShader(program,t),gl.linkProgram(program),gl.getProgramParameter(program,gl.LINK_STATUS)||console.error(gl.getProgramInfoLog(program)),vertices=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1],buffer=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);const e=gl.getAttribLocation(program,"position");gl.enableVertexAttribArray(e),gl.vertexAttribPointer(e,2,gl.FLOAT,!1,0,0),time=gl.getUniformLocation(program,"time"),resolution=gl.getUniformLocation(program,"resolution")}function draw(n){gl.clearColor(0,0,0,1),gl.clear(gl.COLOR_BUFFER_BIT),gl.useProgram(program),gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.uniform1f(time,.001*n),gl.uniform2f(resolution,canvas.width,canvas.height),gl.drawArrays(gl.TRIANGLES,0,.5*vertices.length)}function loop(n){draw(n),requestAnimationFrame(loop)}function init(){setup(),resize(),loop(0)}const canvas=document.getElementById("background"),gl=canvas.getContext("webgl2"),dpr=Math.max(1,window.devicePixelRatio),vertexSource="#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nin vec2 position;\n\nvoid main(void) {\n    gl_Position = vec4(position, 0., 1.);\n}\n",fragmentSource="#version 300 es\n/*********\n* made by Matthias Hurrle (@atzedent)\n*/\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nout vec4 fragColor;\n\nuniform vec2 resolution;\nuniform float time;\n\n#define T time\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n\n    return mat2(c, -s, s, c);\n}\n\nfloat herp(float x) {\n\treturn 3.*x*x - 2.*x*x*x;\n}\n\nfloat circle(vec2 gv, float r, float blur) {\n\tfloat d = 2. * dot(gv, gv);\n\n\treturn smoothstep (\n\t\tr - blur,\n\t\tr + blur,\n\t\td\n\t);\n}\n\nvec3 pattern(vec2 uv) {\n    float fa = 1., fb = 1., fc = 1., fd = .0;\n\n    for (int i = 0; i < 10; i++) {\n        vec2 p = vec2(\n            cos(uv.y * fa - fd + T / fb),\n            sin(uv.x * fa - fd + T / fb)\n        ) / fc;\n        p += vec2(-p.y, p.x) * .3;\n        uv.xy += p;\n\n        fa *= 2.;\n        fb *= 1.5;\n        fc *= 1.75;\n\n        fd += .05 + .1 * T * fb;\n    }\n    float\n    r = sin(uv.x - T) * .5 + .5,\n    b = sin(uv.y + T) * .5 + .5,\n    g = sin((uv.x + uv.y + sin(T * .5)) * .5) * .5 + .5;\n\n    return vec3(r, g, b);\n}\n\nvoid main(void) {\n\tvec2 uv = (\n\t\tgl_FragCoord.xy - .5 * resolution.xy\n\t) / resolution.y;\n\n\tfloat f = herp(.5 * (cos(T * .125) + 1.));\n\tuv *= rot(6.283 * f);\n\n\tfloat zoom = 2. + 6. * f;\n\tuv *= zoom;\n\n\tvec2 gv = fract(uv * zoom) - .5;\n\tvec2 id = floor(uv * zoom);\n\tfloat cos_t = cos(T-id.y*50.);\n\n\tfloat radius = .25 * herp(.5 * cos_t + 1.);\n\tfloat d = circle(gv, radius, 2. / max(resolution.x, resolution.y));\n\td += circle(gv - .05, radius, radius);\n\n\tvec3 col = vec3(1.-d);\n    vec3 st = pattern(uv);\n\n\tfloat\n\tr = min(st.r, .5 * (1. - cos_t) * col.z),\n\tg = min(st.b, .5 * (- cos_t + 1.) * col.x),\n\tb = min(st.g * 2.1, .5 * (1. - cos_t) * col.y),\n    a = 1.;\n\n\tfragColor =\n\t\tvec4(vec3(g, b, r) - st, a) * 4.;\n}\n";let time,buffer,program,resolution,vertices=[];document.body.onload=init,window.onresize=resize;